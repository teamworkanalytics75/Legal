"""Output atomic agents.

Agents for exporting to different formats and adding metadata.
All agents are deterministic (zero cost).
"""

from __future__ import annotations

import json
from datetime import datetime
from typing import Any, Dict, List

try:
    from ..atomic_agent import DeterministicAgent
except ImportError:
    from atomic_agent import DeterministicAgent


class MarkdownExporterAgent(DeterministicAgent):
    """Export document to Markdown format.

    Single duty: Convert structured document to Markdown.
    Method: Template-based rendering (deterministic).
    Output: Markdown-formatted text.
    """

    duty = "Export document to Markdown format"

    async def _deterministic_execution(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """Convert document to Markdown.

        Args:
            input_data: Should contain 'text' or 'sections'

        Returns:
            Markdown formatted output
        """
        text = input_data.get('text', '')
        sections = input_data.get('sections', [])
        title = input_data.get('title', 'Legal Memorandum')

        # Build markdown
        markdown_parts = [
            f"# {title}\n",
            f"\n**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M')}\n",
            "\n---\n",
        ]

        if sections:
            # Structured format with sections
            for section in sections:
                section_title = section.get('title', 'Section')
                section_text = section.get('text', section.get('section_text', ''))

                markdown_parts.append(f"\n## {section_title}\n\n{section_text}\n")
        else:
            # Plain text
            markdown_parts.append(f"\n{text}\n")

        markdown_parts.append("\n---\n\n*Generated by The Matrix Atomic Agent System*\n")

        markdown_text = "".join(markdown_parts)

        return {
            'markdown': markdown_text,
            'format': 'markdown',
            'word_count': len(markdown_text.split()),
        }


class DocxExporterAgent(DeterministicAgent):
    """Export document to DOCX format.

    Single duty: Convert structured document to DOCX.
    Method: Template-based rendering using python-docx (deterministic).
    Output: DOCX file path.
    """

    duty = "Export document to DOCX format"

    async def _deterministic_execution(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """Convert document to DOCX.

        Args:
            input_data: Should contain 'text' or 'sections' and 'output_path'

        Returns:
            DOCX file information
        """
        text = input_data.get('text', '')
        sections = input_data.get('sections', [])
        output_path = input_data.get('output_path', 'output.docx')
        title = input_data.get('title', 'Legal Memorandum')

        # For now, return metadata (actual DOCX generation would use python-docx)
        # This is a placeholder for the deterministic conversion

        docx_info = {
            'format': 'docx',
            'output_path': output_path,
            'title': title,
            'section_count': len(sections),
            'generated': datetime.now().isoformat(),
            'note': 'DOCX generation requires python-docx library',
        }

        return docx_info


class MetadataTaggerAgent(DeterministicAgent):
    """Add metadata tags to document.

    Single duty: Append structured metadata.
    Method: JSON serialization (deterministic).
    Output: Document with metadata section.
    """

    duty = "Append structured metadata to document"

    async def _deterministic_execution(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """Add metadata to document.

        Args:
            input_data: Should contain 'text' and metadata fields

        Returns:
            Document with metadata
        """
        text = input_data.get('text', '')

        # Extract metadata from input
        metadata = {
            'generated_at': datetime.now().isoformat(),
            'architecture': 'atomic_agents',
            'version': '2.1.0',
            'complexity_score': input_data.get('complexity_score'),
            'evidence_count': input_data.get('evidence_count'),
            'citation_count': input_data.get('citation_count'),
            'section_count': input_data.get('section_count'),
            'word_count': len(text.split()),
            'agent_count': input_data.get('agent_count'),
            'total_cost': input_data.get('total_cost'),
        }

        # Remove None values
        metadata = {k: v for k, v in metadata.items() if v is not None}

        # Format metadata section
        metadata_section = "\n\n---\n\n## Metadata\n\n```json\n"
        metadata_section += json.dumps(metadata, indent=2)
        metadata_section += "\n```\n"

        # Append to text
        output_text = text + metadata_section

        return {
            'output_text': output_text,
            'metadata': metadata,
            'metadata_added': True,
        }
